---
title: "R-Project Workflow"
format:
  html:
    self-contained: true
    output-file: "R-Projects Workflow.html"
    toc: true         # Contents 
    toc-depth: 3      # Depth of Heading
    toc-location: right  # (optional) position: "left", "right", "floating"
    number-sections: false  # (optional) Numbering headings 
execute:
  echo: true  
  eval: false      
editor: visual
---

Creates a complete project folder structure according to William S. Noble

Noble WS (2009) A Quick Guide to Organizing Computational Biology Projects. PLoS Comput Biol 5(7): e1000424. doi:10.1371/journal.pcbi.1000424

<br>

Folder Overview

Structure of Projects


Projects/                          # Parent directory for all projects
├── Projectname_1/
│    └── Projectname_1.Rproj
├── Projectname_2/
├── ...
├── global_tools/                  # Important!
│    └── project_starter.R
│    └── helper_functions.R        # other global functions
│    └── stats_functions.R 

<br> <br>

Subdivision of a Project Folder


Projectname_1/
├── data/
│    └── data/raw/                 # Raw data; should not be changed
│    └── data/cleaned/             # Cleaned data 
├── notebooks/                       
│    └── 2025-04-10_notes.md
├── results/                         
│    └── 2025-04-10_cleaning/
│    └── 2025-04-11_descriptive/
├── reports/                         
├── scripts/
│    └── runall_script.R           # Default
│    └── load_lib.R                # Default
│    └── read_config.R             # Relevant for Projectname_1_report.qmd (report_file)
│    └── cleaning_script.R      
│    └── descriptiv_stats.R
│    └── other_scripts.R
├── tests/                            
│    └── validate_input_data.R 
├── Projectname_1_report.qmd       # Default
├── Projectname_1_report.html
├── .gitignore                       
├── Projectname_1.Rproj              
├── _quarto.yml                    # General info about the project/person (README)
├── README.qmd                       
├── renv.lock                      # If include_renv = TRUE

<br> <br>

Workflow

Preparation

A parent folder called "Projects" should have been created. Within "path/to/Projects" a further folder "global_tools" should exist, where the files "project_starter.R" and "functions.R" are stored.

Use getwd() to get your current working directory

Use setwd() if necessary

Working directory should be "path/to/Projects"

<br>

{r}
getwd()
setwd("your_path__/Projects")   # if needed

<br>

You can then source the scripts as follows:

{r}
# For example: global functions 
source("path_to_folder/global_tools/helper_functions.R")
source("path_to_folder/global_tools/stats_functions.R")

# Here is the script with the important functions
source("path_to_folder/global_tools/project_starter.R") 

<br>

Create a Project

fhe following function will automatically create a project folder named "Projectname_1" with all subfolders listed above inside the "Projects" directory.

{r}
create_new_project("Projectname_1")

Output: ✅ Project Projectname_1 was created at: path/to/Projects/Projectname_1

<br>

R Files

<br>

load_lib.R Script

To avoid loading multiple projects' packages globally, it's useful to have a load_lib.R script inside each project's Projects/Projectname_1/scripts folder.

{r}
source("path/to/Projects/Projectname_1/load.lib.R") 

<br>

Working files

In a script such as "cleaning_script.R", before exporting results, use the following function:

{r}
# cleaning Data
results_dir <- create_results_wd("cleaning") 

# or analysis: 
results_dir <- create_results_wd("descriptive_analysis") 

# or other names 
results_dir <- create_results_wd("other_label") 

This will automatically create a new dated subfolder under "Projectname_1/results" and save exports there. The file will use your specified label, e.g. "cleaning".

<br>

Suggestion for exporting interim datasets:

{r}
# export dataset 
# results_dir as defined above
openxlsx::write.xlsx(data, file = file.path(results_dir, 
                                            "result_1_data.csv")) 

openxlsx::write.xlsx(data, file = file.path(results_dir, 
                                            "data_check_or_other_label.csv")) 

quarto_render("reports/_Label_Report.qmd", 
              output_file = "_Label_Report.html", 
              output_dir = "reports")

<br>

If your dataset is fully cleaned and analysis should follow, use the function: save_cleaned_result().

Datasets are then automatically saved in "Projectname_1/data/cleaned" as .xlsx, .csv, and .rds files.

{r}
save_cleaned_result(data, filename_prefix = "cleaned_data") 

# For separator = ";", set: "write_csv2 = TRUE"
save_cleaned_result(data, filename_prefix = "cleaned_data", 
                    write_csv2 = TRUE)

<br>

Folder output:

data/cleaned/
│    └── cleaned_data_2025-04-11.rds
│    └── cleaned_data_2025-04-11.csv
│    └── cleaned_data_2025-04-11.xlsx

<br>

Sensitive Keys or Tokens

With the .Renviron file you create a template for securely storing sensitive tokens or keys, which you can access via

api_token <- Sys.getenv("API_TOKEN")

zu zugreifen.

<br>

Github

A .gitignore file is created for automatic upload to exclude files containing sensitive information, such as API tokens (saved in .Renviron).

Currently excludes .Rhistory, .RData, .Rproj.user, renv/library, data/raw, results/, .Renviron, .env, PDF, HTML_reports. Please adapt as needed if you add other files/folders.

Push to Github via bash.

<br>

README

For important project documentation, especially for others, a README file is included. This is only created once and is a Quarto file, so it can be rendered to PDF or HTML.

<br>

Notebooks

For clean documentation, notes are helpful. Notebooks can be created with the function create_notebook_wd.Default name = "_notes.qmd"

create_notebook_wd("notes")

This will automatically create a new file with the current date and your chosen label in "Projectname_1/notebooks".

<br>

Reports

A Quarto report template is automatically created (Projectname_report.qmd).This template includes all necessary links to functions and libraries.

source('M:/Projects/global_tools/project_starter.R') 
source('M:/Projects/global_tools/functions.R') 
source(here('scripts', 'load_lib.R'))

For reports, the .quarto.yml file is relevant because it contains basic project/person info.Must be adapted as needed.

<br>

runall.R – Central Pipeline

Additionally, a "runall.R" script with the following structure can be used:

<br>

1. Setup

source('scripts/load_lib.R')
source('M:/Projects/global_tools/project_starter.R')
source('M:/Projects/global_tools/functions.R')

2. Clean Data

source('scripts/cleaning_data.R')

Load cleaned datacleaned_data is a list with the latest files in the path /data/cleaned/

cleaned_data <- read_latest_cleaned_data(path = here::here("data", "cleaned"))
head(cleaned_data)
data_clean_1 <- cleaned_data$...
data_clean_2 <- cleaned_data$...
names(cleaned_data)

3. Analysis scripts

source('scripts/descriptiv_stats.R')
source('scripts/run_survival.R')

4. Render Report

if(!requireNamespace('quarto', quietly = TRUE)) install.packages('quarto')
quarto::quarto_render('Some_Report.qmd')

<br>

project_starter.R -File

{r}

# setup project structure
# Path: Projects/global_tools/


# Creates a complete project scaffold following William S. Noble
###      Noble WS (2009) A Quick Guide to Organizing Computational Biology Projects. 
###         PLoS Comput Biol 5(7): e1000424. doi:10.1371/journal.pcbi.1000424


# Packages ----
if (!require("fs")) install.packages("fs")
if (!require("here")) install.packages("here")
if (!require("renv")) install.packages("renv")
if (!require("yaml")) install.packages("yaml")
if (!require("withr")) install.packages("withr")

library(fs)
library(here)
library(yaml)
library(renv)
library(withr)
library(dplyr)





# create_new_project() ----

#' `create_new_project()` creates a new project in the given folder (`getwd()` by default).
#' It generates various folders and files:
#'
#' `(data/, doc/, notebooks/, renv/, reports/, scripts/, tests/, .gitignore, .Renviron, .Rproj, README.qmd)`
#'
#' @param project_name       String. Name of the project.
#' @param base_path          Default: uses the set path.
#' @param include_renv       Default: TRUE. Sets up an isolated renv environment. 
#'                           If FALSE, renv is not used and package consistency cannot be guaranteed over time.
#' @param include_gitignore  Logical. If TRUE: creates a .gitignore file to define which files should not be pushed to GitHub.
#' @param create_readme      Logical. If TRUE: creates a README file for the project.
#'
#' @returns                  Creates the complete folder structure, relevant files, and (optionally) environments.
#'
#' @examples                 `create_new_project("Project1", include_renv = FALSE)`
#'
create_new_project <- function(project_name, 
                               base_path = here::here("Projects"),
                               include_renv = TRUE,
                               include_gitignore = TRUE,
                               create_readme = TRUE) {
  project_path <- file.path(base_path, project_name)
  if (dir_exists(project_path)) {
    stop("❌ Project folder already exists: ", project_path)
  }
  
  today <- format(Sys.Date(), "%Y-%m-%d")
  
  ## directories ----
  dir_create(project_path, recurse = TRUE)

  dirs_to_create <- c(
    "data/raw",
    "data/cleaned",
    "scripts",
    "results",
    "reports",
    "notebooks",
    "doc",
    "tests"
  )
  
  for (d in dirs_to_create) {
    dir_create(path(project_path, d))
  }

  ## .Rproj file ----
  rproj_file <- path(project_path, paste0(project_name, ".Rproj"))
  if (!file_exists(rproj_file)) {
    file_create(rproj_file)
    writeLines(
      c(
        "Version: 1.0",
        "",
        "RestoreWorkspace: No",
        "SaveWorkspace: No",
        "AlwaysSaveHistory: Default",
        "",
        "EnableCodeIndexing: Yes",
        "UseSpacesForTab: Yes",
        "NumSpacesForTab: 2",
        "Encoding: UTF-8",
        "",
        "RnwWeave: knitr",
        "LaTeX: pdfLaTeX"
      ),
      con = rproj_file
    )
  }

  ## config.yaml ----
  # Configuration file with header info
  config <- list(
    project_name = project_name,
    created = today,
    user = "..."                              # Edit as needed
  )
  write_yaml(config, file.path(project_path, "reports", "config.yaml"))

  # read_config.R ----
  # Helper script to read config.yaml; used for the report header
  read_config_file <- path(project_path, "scripts", "read_config.R")
  if (!file_exists(read_config_file)) {
    writeLines(
      c(
        "# scripts/read_config.R",
        "",
        "read_project_config <- function(config_path = here('reports', 'config.yaml')) {",
        "  if (!file.exists(config_path)) {",
        "    warning('⚠️ config.yaml not found, using default values.')",
        "    return(list(project_name = 'Unknown Project', created = Sys.Date(), user = Sys.info()['user']))",
        "  }",
        "  yaml::read_yaml(config_path)",
        "}"
      ),
      con = read_config_file
    )
  }

  ## quarto.yml ----
  # For Quarto project structure
  quarto_config <- list(
    project = list(
      type = "default",
      `execute-dir` = "project"
    )
  )
  write_yaml(quarto_config, file.path(project_path, "reports", "_quarto.yml")) 

  ## load_lib.R ----
  # Automatically created based on renv::dependencies()
  lib_file <- path(project_path, "scripts", "load_lib.R")
  if (!file_exists(lib_file)) {

    # Default packages regularly used (also relevant for renv snapshot)
    default_pkgs <- c(
      "boot", "car", "conflicted", "DataExplorer", 
      "fs", "ggdist", "ggforce", "gghalves", "ggpp", "ggpubr", "ggsurvfit", "gtsummary",   
      "here", "Hmisc", "httr",
      "kableExtra", "knitr", 
      "magrittr", "MASS", "openxlsx", 
      "pacman", "patchwork",
      "readr", "readxl", "REDCapR", "REDCapTidieR", "rmarkdown", 
      "skimr", "survival", "survminer",
      "testthat", "tidyverse", "tidymodels",
      "stringi", 
      "yaml" 
    )
    # Optional packages (can sometimes cause problems with renv initialization)
    optional_pkgs <- c("colorblindr")

    writeLines(
      c(
        "# scripts/load_lib.R",
        "# Loads all required packages",
        "",
        "required_packages <- c(",
        paste0('  "', default_pkgs, '"', collapse = ",\n"),
        ")",
        "",
        "optional_packages <- c(",
        paste0('  "', optional_pkgs, '"', collapse = ",\n"),
        ")",
        "",
        "install_if_missing <- function(pkg) {",
        "  if (!requireNamespace(pkg, quietly = TRUE)) {",
        "    tryCatch({",
        "      install.packages(pkg)",
        "    }, error = function(e) {",
        "      message('⚠️ Package could not be installed: ', pkg)",
        "    })",
        "  }",
        "}",
        "",
        "# Install and load main packages",
        "invisible(lapply(required_packages, install_if_missing))",
        "invisible(lapply(required_packages, function(pkg) library(pkg, character.only = TRUE)))",
        "",
        "# Install optional packages (no error if unavailable)",
        "invisible(lapply(optional_packages, install_if_missing))",
        "",
        "message('✅ All core packages loaded. Optional packages if available.')"
      ),
      con = lib_file
    )
  }

  ## Notebook ----
  results_today <- path(project_path, "results", paste0(today, "_initial"))
  notebook_today <- path(project_path, "notebooks", paste0(today, "_notes.qmd"))
  if (!dir_exists(results_today)) dir_create(results_today)
  if (!file_exists(notebook_today)) {
    writeLines(
      c(
        "---",
        paste0('title: "', project_name, ' – Notebook"'),
        "format:",
        "  html:",
        "    self-contained: true",
        "execute-dir: project",
        "---",
        paste0("# Notes – ", today),
        "",
        paste0("**Project:** ", project_name),
        paste0("**Date:** ", today),
        paste0("**User:** ", "..."),
        paste0("**Session:** ", R.version.string),
        "",
        "## Goal:",
        "",
        "## Steps:",
        "",
        "## Observations:",
        "",
        "## Problems / Next Steps:"
      ),
      con = notebook_today
    )
  }

  
  
  ## README ----
  # Project documentation for key points               (customize as needed)
  if (create_readme) {
    readme_file <- path(project_path, "README.qmd")
    writeLines(
      c(
        "---",
        paste0('title: "', project_name, ' – README"'),
        "format:",
        "  html:",
        "    toc: true",
        "    toc-depth: 2",
        "    number-sections: true",
        "    self-contained: true",
        "    output-file: README.html",
        "---",
        "",
        paste0("# Project: ", project_name),
        "",
        "## Author",
        paste0("- User: ..."),                         # Edit as needed
        paste0("- Created on: ", today),
        "",
        "## Overview",
        "- `data/`: Raw and cleaned data",
        "- `scripts/`: Analysis scripts",
        "- `results/`: Results & outputs",
        "- `reports/`: Reports",
        "- `notebooks/`: Notes",
        "- `tests/`: Tests",
        "",
        "## Documentation",
        "### Relevant formulas, etc.",
        "",
        "## Planning Contents",
        "",
        "### 01 – Background & Literature",
        "- Literature, publications",
        "",
        "### 02 – Research Questions",,
        "    Objectives and hypotheses",

        "",
        "",
        "",
        "### 03 – Statistical Methods",
        "```{r}",
        "",
        "```",
        "",
        "### 04 – Statistical Analysis Plan",
        "",
        "",
        "### 05 – Publication Plan",
        "- Target journals, authors, deadlines",
        ""
      ),
      con = readme_file
    )
    message("✅ README.qmd has been created.")
  }

  
  
  
  # renv ----
  # renv environment to freeze used packages
  # Only active if -- include_renv = TRUE --
  # If a new package is installed, renv will usually recognize it and update.
  # Otherwise use: renv::snapshot() for all, or renv::snapshot(packages = "ggpubr") for one.
  if (include_renv) {
    if (requireNamespace("renv", quietly = TRUE)) {
      message("🔒 Initializing renv for project: ", project_name)
      renv::scaffold(project = project_path)
      message("📦 Project structure created.")
      
      withr::with_dir(project_path, {
        if (file.exists("scripts/load_lib.R")) {
          source("scripts/load_lib.R")
        }
        renv::snapshot(prompt = FALSE)
      })
      
      message("📦 renv.lock updated for project: ", project_name)
      message("✅ Project created with renv.")
    } else {
      warning("❌ renv package not installed. Project created without renv.")
    }
  } else {
    message("✅ Project created without renv.")
  }
  
  message("✅ Project '", project_name, "' created at: ", project_path)

  # .Renviron ----
  # For API tokens or other sensitive keys, e.g. REDCap
  renviron_path <- file.path(project_path, ".Renviron")
  if (!file.exists(renviron_path)) {
    writeLines(
      c(
        "# Project-wide environment variables",
        "# Example:",
        "# API_TOKEN=your_token",
        "# api_url=https:// ..."
      ),
      con = renviron_path
    )
    message("✅ .Renviron file created for API keys and secrets.")
  }

  # Report Template ----
  # Default template for generating reports as HTML files.
  report_file <- path(project_path, "reports", paste0(project_name, "_report.qmd"))
  if (!file_exists(report_file)) {
    writeLines(
      c(
        "---",
        paste0('title: "', project_name, ' – Report"'),
        "format:",
        "  html:",
        "    self-contained: true",
        paste0('    output-file: "', project_name, '_report.html"'),
        "output-dir: null",
        "execute-dir: project",
        "---",
        "",
        "```{r}",
        "#| include: false",
        "library(here)",
        "library(yaml)",
        "source(here('scripts', 'read_config.R'))",
        "config <- read_project_config()",
        "",
        "```",
        "",
        "# Overview",
        "",
        "Project: `r config$project_name`  ",
        "Created on: `r config$created`  ",
        "Author: `r config$user`",
        "",
        "## Analysis",
        "",
        "```{r}",
        "#| include: false",
        "",
        "source('M:/Projects/global_tools/project_starter.R')",
        "source('M:/Projects/global_tools/stats_functions.R')",
        "source(here('scripts', 'load_lib.R'))",
        "",
        "```"
      ),
      con = report_file
    )
    message("✅ ", project_name, "_report.qmd has been created in ", report_file)
  }

  # runall.R Template ----
  runall_file <- path(project_path, "scripts", "runall.R")
  if (!file_exists(runall_file)) {
    get_last_date <- list.files(
      path = file.path(project_path, "data/cleaned"),
      pattern = "cleaned_data_\\d{4}-\\d{2}-\\d{2}\\.rds$",
      full.names = FALSE
    ) %>%
      sort(decreasing = TRUE) %>%
      first() %>%
      stringr::str_extract("\\d{4}-\\d{2}-\\d{2}")

    writeLines(
      c(
        "# runall.R – Central analysis pipeline",
        "",
        "",
        "# 1. Setup",
        "source('scripts/load_lib.R')",
        "source('M:/Projects/global_tools/project_starter.R')",
        "source('M:/Projects/global_tools/stats_functions.R')",          # Adjust function name if needed
        "",
        "",
        "# 2. Data cleaning",
        "source('scripts/cleaning_data.R')",
        "",
        "# Load cleaned data",
        "",
        "cleaned_data <- read_latest_cleaned_data()",
        "names(cleaned_data)",
        "",
        "data_1 <- cleaned_data$__NAME__",
        "data_2 <- cleaned_data$__NAME__",
        "",
        "",
        "# 3. Analysis scripts",
        "# source('scripts/run_descriptive.R')",
        "# source('scripts/run_survival.R')",
        "",
        "",
        "if (!requireNamespace('quarto', quietly = TRUE)) install.packages('quarto')",
        paste0("quarto::quarto_render(", project_name, "_report.qmd)"),
        "",
        "",
        "# 4. Save results",
        "# Results can be saved as needed,", 
        "# e.g. with openxlsx::write.xlsx(),",
        "# or with save_cleaned_result()",
        ""
      ),
      con = runall_file
    )
  }

  # Tests ----
  # Test file for checking/validating data quality, etc.
  validation_file <- path(project_path, "tests", "validate_input_data.R")
  writeLines(
    c(
      "# validate_input_data.R",
      "",
      "",
      "# Simple data checks",
      "# Example: data <- read.csv('data/raw/data.csv')",
      "# str(data)",
      "# summary(data)",
      "# anyDuplicated(data)",
      "# sapply(data, function(x) sum(is.na(x)))"
    ),
    con = validation_file
  )

  # Testthat ----
  # Integrate testthat test structure
  testthat_file <- path(project_path, "tests", "test_data_checks.R")  
  writeLines(
    c(
      "# tests/test_data_checks.R",
      "library(testthat)",
      "",
      "test_that('Data contains no missing values', {",
      "  skip_if_not(file.exists('data/raw/data.csv'))",
      "  data <- read.csv('data/raw/data.csv')",
      "  expect_true(all(complete.cases(data)))",
      "})"
    ),
    con = testthat_file
  )
  message("✅ testthat skeleton created.")

  # .gitignore ----
  if (include_gitignore) {
    gitignore_content <-
      c(
        "# R",
        ".Rhistory",
        ".RData",
        ".Rproj.user",
        "",
        "# renv",
        "renv/library/",
        "renv/python/",
        "renv/staging/",
        "",
        "# Data",
        "data/raw/",
        "*.xlsx",
        "*.csv",
        "*.rds",
        "",
        "# Results",
        "results/",
        "",
        "# HTML/PDF",
        "*.html",
        "*.pdf",
        "",
        "# Sensitive Files",
        "scripts/config.R",
        ".Renviron",         # R 
        ".env"               # Python 
      )
    writeLines(gitignore_content, file.path(project_path, ".gitignore"))
    message("✅ .gitignore has been created.")
  }
}








create_results_wd <- function(analysis_type){
  today <- format(Sys.Date(), "%Y-%m-%d")
  results_dir <- file.path("results", paste0(today, "_", analysis_type))
  if (!dir.exists(results_dir)) dir.create(results_dir, recursive = TRUE)
  return(results_dir)
}












create_tests_wd <- function(analysis_type){
  today <- format(Sys.Date(), "%Y-%m-%d")
  results_dir <- file.path("tests", paste0(today, "_", analysis_type))
  if (!dir.exists(results_dir)) dir.create(results_dir, recursive = TRUE)
  return(results_dir)
}











create_notebook_wd <- function(topic = "notes") {
  today <- format(Sys.Date(), "%Y-%m-%d")
  notebook_name <- paste0(today, "_", topic, ".qmd")
  notebook_path <- file.path("notebooks", notebook_name)
  
  if (!dir.exists("notebooks")) dir.create("notebooks", recursive = TRUE)
  
  if (!file.exists(notebook_path)) {
    writeLines(
      c(
        paste0("# Notes – ", today),
        "",
        paste0("**Topic:** ", topic),
        paste0("**Project:** ", basename(here::here())),
        paste0("**Date:** ", today),
        paste0("**User:** ", Sys.info()["user"]),
        paste0("**Session:** ", R.version.string),
        "",
        "## Goals",
        "",
        "- ",
        "",
        "## Steps",
        "",
        "- ",
        "",
        "## Comments",
        "",
        "- ",
        "",
        "## Problems / Next steps",
        "",
        "- "
      ),
      con = notebook_path
    )
    message("✅ Notebook created: ", notebook_path)
  } else {
    message("⚠️ Notebook already exists: ", notebook_path)
  }
  
  return(notebook_path)
}













save_cleaned_result <- function(data, 
                                filename_prefix = "cleaned_data", 
                                cleaned_dir = "data/cleaned", 
                                write_csv2 = FALSE) {
  
  if (!dir.exists(cleaned_dir)) dir.create(cleaned_dir, recursive = TRUE)
  
  # Date
  today <- format(Sys.Date(), "%Y-%m-%d")
  
  # Filename
  base_name <- paste0(filename_prefix, "_", today)
  path_rds   <- file.path(cleaned_dir, paste0(base_name, ".rds"))
  path_csv   <- file.path(cleaned_dir, paste0(base_name, ".csv"))
  path_xlsx  <- file.path(cleaned_dir, paste0(base_name, ".xlsx"))
  
  # Speichern
  saveRDS(data, path_rds)
  
  if (write_csv2) {
    write.csv2(data, path_csv, row.names = FALSE)  # separator ; for Excel 
  } else {
    write.csv(data, path_csv, row.names = FALSE)   # separator ,
  }
  
  if (!requireNamespace("openxlsx", quietly = TRUE)) install.packages("openxlsx")
  openxlsx::write.xlsx(data, path_xlsx)
  
  message("✅ Saved as: ", basename(path_rds), ", ", basename(path_csv), ", ", basename(path_xlsx))
  
  invisible(list(rds = path_rds, csv = path_csv, xlsx = path_xlsx))
}



<br>

Helper functions

{r}
# Helper functions 
# Path: Projects/global_tools/



# get_global_tool_path() ----

#' Returns the full path to a file in the global_tools directory using the here package.
#'
#' @param filename  String. The filename (with extension) you want the path for.
#'
#' @return          String with the complete path to the file in global_tools.
#'
get_global_tool_path <- function(filename) {
  here("global_tools", filename)
}






# create_results_wd() ---- 

#' Creates (if necessary) and returns the path to a results subfolder,
#' named with the current date and a user-supplied label.
#'
#' @param analysis_type  String. Label for the analysis or result type (e.g., "cleaning", "descriptive").
#'
#' @return               String with the path to the results subfolder.
#'
#' @examples
#' results_dir <- create_results_wd("descriptive")
create_results_wd <- function(analysis_type){
  today <- format(Sys.Date(), "%Y-%m-%d")
  results_dir <- here::here("results", paste0(today, "_", analysis_type))
  if (!dir.exists(results_dir)) dir.create(results_dir, recursive = TRUE)
  return(results_dir)
}







# create_tests_wd() ----

#' Creates (if necessary) and returns the path to a tests subfolder,
#' named with the current date and a user-supplied label.
#'
#' @param analysis_type  String. Label for the test or validation type.
#'
#' @return               String with the path to the test subfolder.
#'
#' @examples
#' tests_dir <- create_tests_wd("input_validation")
create_tests_wd <- function(analysis_type){
  today <- format(Sys.Date(), "%Y-%m-%d")
  results_dir <- here::here("tests", paste0(today, "_", analysis_type))
  if (!dir.exists(results_dir)) dir.create(results_dir, recursive = TRUE)
  return(results_dir)
}






# create_notebook_wd() ----

#' Creates a new Quarto notebook file in the notebooks directory,
#' named with the current date and an optional topic.
#'
#' @param topic   String. Topic or label for the notebook file. Default: "notes".
#'
#' @return        String with the path to the new notebook file.
#'
#' @examples
#' notebook_file <- create_notebook_wd("eda")
create_notebook_wd <- function(topic = "notes") {
  # Define date, name, and path
  today <- format(Sys.Date(), "%Y-%m-%d")
  notebook_name <- paste0(today, "_", topic, ".qmd")
  notebook_path <- here("notebooks", notebook_name)
  
  # Check if folder already exists
  if (!dir.exists(here("notebooks"))) dir.create(here("notebooks"), recursive = TRUE)
  
  if (!file.exists(notebook_path)) {
    # Create notebook template (customize if needed)
    writeLines(
      c(
        paste0("# Notes – ", today),
        "",
        paste0("**Topic:** ", topic),
        paste0("**Project:** ", basename(here::here())),
        paste0("**Date:** ", today),
        paste0("**User:** ", Sys.info()["user"]),
        paste0("**Session:** ", R.version.string),
        "",
        "## Goal(s)",
        "",
        "- ",
        "",
        "## Steps",
        "",
        "- ",
        "",
        "## Observations",
        "",
        "- ",
        "",
        "## Problems / Next Steps",
        "",
        "- "
      ),
      con = notebook_path
    )
    message("✅ Notebook created: ", notebook_path)
  } else {
    message("⚠️ Notebook already exists: ", notebook_path)
  }
  
  return(notebook_path)
}






# save_cleaned_result() ----

#' `save_cleaned_result()` saves a data object in three formats (csv, xlsx, rds)
#' in the folder data/cleaned/.
#'
#' @param data                The data object to save.
#' @param filename_prefix     String, used as the base name for the saved files.
#' @param cleaned_dir         Default: data/cleaned/ directory.
#' @param write_csv2          If TRUE: uses semicolon as CSV separator (write.csv2).
#' @param create_latest_copy  If TRUE: creates a copy named `latest_NAME.rds`.
#'
#' @returns                   Writes three files (xlsx, csv, rds) + `latest_NAME.rds`.
#'
#' @examples                  `save_cleaned_result(data, filename_prefix = "therapy_lines")`
#'
save_cleaned_result <- function(data, 
                                filename_prefix = "cleaned_data", 
                                cleaned_dir = "data/cleaned", 
                                write_csv2 = FALSE,
                                create_latest_copy = TRUE) {
  
  # Ensure directory exists
  if (!dir.exists(cleaned_dir)) dir.create(cleaned_dir, recursive = TRUE)
  
  # Date
  today <- format(Sys.Date(), "%Y-%m-%d")
  
  # File names
  base_name <- paste0(filename_prefix, "_", today)
  path_rds   <- file.path(cleaned_dir, paste0(base_name, "_data.rds"))
  path_csv   <- file.path(cleaned_dir, paste0(base_name, "_data.csv"))
  path_xlsx  <- file.path(cleaned_dir, paste0(base_name, "_data.xlsx"))
  
  # Save files
  saveRDS(data, path_rds)
  
  if (write_csv2) {
    write.csv2(data, path_csv, row.names = FALSE)  # with ; as separator (for Excel on Windows)
  } else {
    write.csv(data, path_csv, row.names = FALSE)   # with , as separator
  }
  
  if (!requireNamespace("openxlsx", quietly = TRUE)) install.packages("openxlsx")
  openxlsx::write.xlsx(data, path_xlsx)
  
  if (create_latest_copy) {
    latest_rds_path <- file.path(cleaned_dir, paste0("latest_", filename_prefix, "_data.rds"))
    file.copy(path_rds, latest_rds_path, overwrite = TRUE)
  }
  
  message("✅ Saved as: ", basename(path_rds), ", ", basename(path_csv), ", ", basename(path_xlsx))
  
  invisible(list(rds = path_rds, csv = path_csv, xlsx = path_xlsx))
}








# read_latest_cleaned_data() ----

#' `read_latest_cleaned_data()` returns a list of all cleaned datasets from the
#' `data/cleaned/` directory, which makes it easier to read them in the `runall.R` file.
#'
#' @param path    Default path: data/cleaned
#'
#' @returns       List of all datasets: access via `cleaned_data_list[["__NAME__"]]`
#'                                           or `cleaned_data_list$__NAME__`
#'
#' @examples
read_latest_cleaned_data <- function(path = file.path("data", "cleaned")) {
  
  if (!dir.exists(path)) {
    warning("⚠️ Directory not found: ", path)
    return(list())
  }
  
  latest_files <- list.files(
    path = path,
    pattern = "^latest_.*_data\\.rds$",
    full.names = TRUE
  )
  
  if (length(latest_files) == 0) {
    warning("⚠️ No files matching 'latest_*.rds' found in ", path)
    return(list())
  }
  
  data_list <- lapply(latest_files, readRDS)
  names(data_list) <- gsub("^latest_(.*)_data\\.rds$", "\\1", basename(latest_files))
  
  message("✅ Datasets loaded:", paste(names(data_list), collapse = ", "))
  return(data_list)
}


