---
title: "R-Projekte Starter Workflow"
format:
  html:
    self-contained: true
    output-file: "R-Projekte Workflow.html"
    toc: true         # Inhaltsverzeichnis aktivieren
    toc-depth: 3      # Tiefe: bis H2 (## Überschriften)
    toc-location: right  # (optional) Position: "left", "right", "floating"
    number-sections: false  # (optional) Überschriften nummerieren
execute:
  echo: true  
  eval: false      
editor: visual
---

Erstellt eine vollständige Projektordnerstruktur nach William S. Noble

Noble WS (2009) A Quick Guide to Organizing Computational Biology Projects. PLoS Comput Biol 5(7): e1000424. doi:10.1371/journal.pcbi.1000424

<br>

# Ordnerüberblick

## Aufteilung der Projekte

``` text

Projects/                          # Übergeordneter Ordner für alle Projekte
├── Projectname_1/
│    └── Projectname_1.Rproj
├── Projectname_2/
├── ...
├── global_tools/                  # Wichtig!
│    └── project_starter.R
│    └── helper_functions.R        # andere globale Funktionen
│    └── stats_functions.R 
```

<br> <br>

## Unterteilung des "Projekte" Ordners

``` text

Projectname_1/
├── data/
│    └── data/raw/                 # Raw data; sollte nicht verändert werden
│    └── data/cleaned/             # Cleaned data 
├── notebooks/                       
│    └── 2025-04-10_notizen.md
├── results/                         
│    └── 2025-04-10_cleaning/
│    └── 2025-04-11_deskriptiv/
├── reports/                         
├── scripts/
│    └── runall_script.R           # Default
│    └── load_lib.R                # Default
│    └── read_config.R             # Relevant für Porjektname_1_report.qmd (report_file)
│    └── cleaning_script.R      
│    └── descriptiv_stats.R
│    └── Andere_Skripte.R
├── tests/                            
│    └── validate_input_data.R 
├── Projectname_1_report.qmd       # Default
├── Projectname_1_report.html
├── .gitignore                       
├── Projectname_1.Rporj              
├── _quarto.yml                    # Festlegung der Grundinfo zur Person (README)
├── README.qmd                       
├── renv.lock                      # Falls include_renv = TRUE
```

<br> <br> <br>

# Workflow

## Vorbereitung

Ein übergeordneter Ordner mit dem Namen "**`Projects`**" sollte erstellt worden sein.\
In dem Ordner "**`path/to/Projects`**" sollte ein weiterer Ordner "**`global_tools`**" erstellt werden. Hier werden die Files "**`project_starter.R`**" und "**`functions.R`**" gespeichert.

-   **`getwd()`** verwenden um deie derzeitige Working Directory zu erhalten

-   **`setwd()`** bei Bedarf verwenden

-   Working Directory sollte bei "**`path/to/``Projects`**" sein

    <br>

```{r}

getwd()
setwd("Pfad_eingeben__/Projects")   # bei Bedarf
```

<br>

Anschließend wird auf die beiden Skripte zugegriffen mittels:

```{r}
# z.b. globale Funktionen 
source("Pfad_____zum_____Ornder/global_tools/helper_functions.R")
source("Pfad_____zum_____Ornder/global_tools/stats_functions.R")


# hier ist das Skript mit den wichtigen Funktionen drinnen
source("Pfad_____zum_____Ordner/global_tools/project_starter.R") 
```

<br><br>

## Projekt erstellen

folgende Funktion erstellt automatisch einen Projekt-Ordner mit dem Namen "Projectname_1" und den oben gelisteten Unterordnern im Ordner "Projects".

```{r}
create_new_project("Projectname_1")
```

Output: ✅ Projekt Projectname_1 wurde erstellt unter: **`path/to/Projects/Projectname_1`**

<br>

<br>

## R-Files

<br>

### load_lib.R Skript

Um nicht immer mehrere Projekte global zu laden macht es Sinn ein **`load.lib.R`** Skript jeweils im Peojektordner **`Projects/Projectname_1``/scripts`** zu speichern.

```{r}
source("path/to/Projects/Projectname_1/load.lib.R") 
```

<br>

<br>

### Working files

In einem File z.b. "**`data_cleaning.R`**" zum cleanen der Daten, sollte vor Export der Resultate folgende Funktion verwendet werden:

```{r}
# cleaning Data
results_dir <- create_results_wd("cleaning") 

# oder Analyse: 
results_dir <- create_results_wd("deskriptive_analysis") 

# oder andere Bezeichnungen 
results_dir <- create_results_wd("andere_Bezeichnung") 
```

Dadurch wird automatisch im Ordner "**`Projectname_1/results`**" ein weiterer Ornder mit dem aktuellen Datum erstellt und unter Verwendung des results_dir der Export gespeichert. Dabei hat die Datei dann die verwendete Bezeichnung wie z.B. "**cleaning**".

<br>

Vorschlag zum Export einzelner Datensätze für zwischen-Resultate:

```{r}
# export dataset 
# results_dir von oben
openxlsx::write.xlsx(data, file = file.path(results_dir, 
                                            "result_1_data.csv")) 


openxlsx::write.xlsx(data, file = file.path(results_dir, 
                                            "data_check_oder_eine_andere_Bezeichnung.csv")) 


quarto_render("reports/_Bezeichnung_Report.qmd", 
              output_file = "_Bezeichnung_Report.html", 
              output_dir = "reports")
```

<br>

Sollte der Datensatz komplett gecleant sein und anschließende Analyse folgen, wird folgende Funktion verwendet: **`save_cleaned_result()`**.

Datensätze werden dann automatisch im Ordner "**`Projectname_1/data/cleaned`**" gespeichert. Die Funktion erstellt automatisch `.xlsx, .csv,` und `.rds` Dateien.

```{r}
save_cleaned_result(data, filename_prefix = "cleaned_data") 


# Bei Separator = ";", function anpassen auf: " write_csv2 = TRUE" 
save_cleaned_result(data, filename_prefix = "cleaned_data", 
                    write_csv2 = TRUE)
```

<br>

**Ordner Output:**

``` text
data/cleaned/
│    └── cleaned_data_2025-04-11.rds
│    └── cleaned_data_2025-04-11.csv
│    └── cleaned_data_2025-04-11.xlsx
```

<br>

<br>

### Sensible Schlüssel oder Token

Mit der Datei .Renviron wird eine Vorlage erstellt, die es ermöglicht, sensible Token oder Schlüssel zu speichern und z.B. mittels

``` r
api_token <- Sys.getenv("API_TOKEN")
```

zu zugreifen.

<br>

<br>

### Github

Zum Automatischen Upload wird eine .gitignore Datei erstellt. Diese schließt relevante Dateien aus, die sensible Infos enthalten, wie API token (gespeichert in .Renviron).

[**Wichtig:**]{.underline} **bisher nur für `.Rhistory, .RData, .Rproj.user, renv/library, datra/raw, results/, .Renviron, .env, PDF, HTML_reports`.\
Bitte anpassen, falls was dazu kommt.**

Github push mittels bash.

<br>

<br>

### README

Für wichtige Dokumentaionen im Projekt, die auch andere betreffen ist eine `REDAME` Datei angelegt, um allgemeines festzuhalten. Diese wird nur einmal erstellt und ist ein Quarto-File, kann also in ein PDF oder HTML File gerendert werden.

<br>

<br>

### Notebooks

Für eine saubere Dokumentation sind Notizen sehr hilfreich. Notebooks können mit Hilfe der Funktion create_notebook_wd. Diese erstellt ein Quart\
Default-Bezeichnung = "`_notizen.qmd`"

``` r
create_notebook_wd("notizen")
```

Dadurch wird automatisch im Ordner "**`Projectname_1/notebooks`**" eine weitere Datei mit dem aktuellen Datum und der Bezeichnung erstellt. Dabei hat die Datei dann die verwendete Bezeichnung wie z.B. "notizen".

<br>

<br>

### Reports

Es wird automatisch eine Quarto-Report-Vorlage erstellt (`Projectname_report.qmd`).\
Diese enthält automatisch alle relevanten Zugriffe auf die Files, wie Funktionen oder Libraries.

``` r
source('M:/Projekte/global_tools/project_starter.R') 
source('M:/Projekte/global_tools/functions.R') 
source(here('scripts', 'load_lib.R'))
```

Für die Reports sind die Files **`.quarto.yml`** relevant, da hier die Grundinfo von der Person enthalten sind.\
Muss angepasst werden.

<br>

<br>

### runall.R – Zentrale Pipeline

Ergänzend kann noch ein "**`runall.R`"** Skript, mit folgendem Aufbau verwendet werden:

<br>

1\. Setup

``` r
source('scripts/load_lib.R')
source('M:/Projekte/global_tools/project_starter.R')
source('M:/Projekte/global_tools/functions.R')
```

2\. Daten cleanen

``` r
source('scripts/cleaning_data.R')
```

cleane Daten einlesen

``` r
cleaned_data <- read_latest_cleaned_data(path = here::here("data", "cleaned"))
head(cleaned_data)
data_clean_1 <- cleaned_data$...
data_clean_2 <- cleaned_data$...
names(cleaned_data)
```

3\. Analyse-Skripte

``` r
source('scripts/descriptiv_stats.R')
source('scripts/run_survival.R')
```

4\. Report erstellen (rendern)

``` r
if(!requireNamespace('quarto', quietly = TRUE)) install.packages('quarto')
quarto::quarto_render('FL_Register_Report.qmd')
```

<br>

<br>

### project_starter.R -File

```{r}



# setup_project_structure 
# Erstellt ein vollständiges Projektgerüst nach William S. Noble

###      Noble WS (2009) A Quick Guide to Organizing Computational Biology Projects. PLoS Comput
###      Biol 5(7): e1000424. doi:10.1371/journal.pcbi.1000424



# Packages ----
if (!require("fs")) install.packages("fs")
if (!require("here")) install.packages("here")
if (!require("renv")) install.packages("renv")
if (!require("yaml")) install.packages("yaml")
if (!require("withr")) install.packages("withr")

library(fs)
library(here)
library(yaml)
library(renv)
library(withr)



create_new_project <- function(project_name, base_path = getwd(),
                               include_renv = TRUE,
                               include_templates = TRUE,
                               include_gitignore = TRUE,
                               create_readme = TRUE) {
  project_path <- file.path(base_path, project_name)
  if (dir_exists(project_path)) {
    stop("❌ Projektordner existiert bereits: ", project_path)
  }
  
  dir_create(project_path, recurse = TRUE)
  
  dirs_to_create <- c(
    "data/raw",
    "data/cleaned",
    "scripts",
    "results",
    "reports",
    "notebooks",
    "doc",
    "tests"
  )
  
  for (d in dirs_to_create) {
    dir_create(path(project_path, d))
  }
  
  # .Rproj-Datei anlegen ----
  rproj_file <- path(project_path, paste0(project_name, ".Rproj"))
  if (!file_exists(rproj_file)) {
    file_create(rproj_file)
    writeLines(
      c(
        "Version: 1.0",
        "",
        "RestoreWorkspace: No",
        "SaveWorkspace: No",
        "AlwaysSaveHistory: Default",
        "",
        "EnableCodeIndexing: Yes",
        "UseSpacesForTab: Yes",
        "NumSpacesForTab: 2",
        "Encoding: UTF-8",
        "",
        "RnwWeave: knitr",
        "LaTeX: pdfLaTeX"
      ),
      con = rproj_file
    )
  }
  
  # Notebook ----
  today <- format(Sys.Date(), "%Y-%m-%d")
  results_today <- path(project_path, "results", paste0(today, "_initial"))
  notebook_today <- path(project_path, "notebooks", paste0(today, "_notizen.qmd"))
  
  if (!dir_exists(results_today)) dir_create(results_today)
  
  if (!file_exists(notebook_today)) {
    writeLines(
      c(
        paste0("# Notizen – ", today),
        "",
        paste0("**Projekt:** ", project_name),
        paste0("**Datum:** ", today),
        paste0("**User:** ", Sys.info()["user"]),
        paste0("**Session:** ", R.version.string),
        "",
        "## Ziel:",
        "",
        "## Schritte:",
        "",
        "## Beobachtungen:",
        "",
        "## Probleme / Nächste Schritte:"
      ),
      con = notebook_today
    )
  }
  
  # runall.R Template ----
  runall_file <- path(project_path, "scripts", "runall.R")
  if (!file_exists(runall_file)) {
    writeLines(
      c(
        "# runall.R – Zentrale Analysepipeline",
        "",
        "",
        "# 1. Setup",
        "source('scripts/load_lib.R')",
        "source('M:/Projekte/global_tools/project_starter.R')",
        "source('M:/Projekte/global_tools/functions.R')",
        "",
        "",
        "# 2. Daten cleanen",
        "source('scripts/cleaning_data.R')",
        "",
        "# cleane Daten einlesen",
        "cleaned_data <- readRDS('data/cleaned/your_clean_data.rds')",
        "",
        "",
        "# 3. Analyse-Skripte",
        "# source('scripts/run_deskriptiv.R')",
        "# source('scripts/run_survival.R')",
        "if (!requireNamespace('quarto', quietly = TRUE)) install.packages('quarto')",
        "quarto::quarto_render('FL_Register_Report.qmd')",
        "",
        "",
        "# 4. Ergebnisse speichern",
        "",
        ""
      ),
      con = runall_file
    )
  }
  
  # load_lib.R ----
  # automatisch erstellen basierend auf renv::dependencies()
  lib_file <- path(project_path, "scripts", "load_lib.R")
  if (!file_exists(lib_file)) {
    
    default_pkgs <- c(
      "tidyverse", "readxl", "openxlsx", "survival", "survminer",
      "gtsummary", "fs", "here", "knitr", "car", "ggpp", "ggpubr",
      "patchwork", "kableExtra", "httr", "pacman",
      "ggsurvfit", "conflicted", "tidymodels", "readr", 
      "yaml", "rmarkdown", "magrittr", "stringi"
    )
    
    optional_pkgs <- c(
      "colorblindr"
    )
    
    writeLines(
      c(
        "# scripts/load_lib.R",
        "# Lädt alle benötigten Pakete",
        "",
        "required_packages <- c(",
        paste0('  "', default_pkgs, '"', collapse = ",\n"),
        ")",
        "",
        "optional_packages <- c(",
        paste0('  "', optional_pkgs, '"', collapse = ",\n"),
        ")",
        "",
        "install_if_missing <- function(pkg) {",
        "  if (!requireNamespace(pkg, quietly = TRUE)) {",
        "    tryCatch({",
        "      install.packages(pkg)",
        "    }, error = function(e) {",
        "      message('⚠️ Paket konnte nicht installiert werden: ', pkg)",
        "    })",
        "  }",
        "}",
        "",
        "# Hauptpakete installieren und laden",
        "invisible(lapply(required_packages, install_if_missing))",
        "invisible(lapply(required_packages, function(pkg) library(pkg, character.only = TRUE)))",
        "",
        "# Optionale Pakete installieren (keine Fehlermeldung bei Problemen)",
        "invisible(lapply(optional_packages, install_if_missing))",
        "",
        "message('✅ Alle Kernpakete geladen. Optionale Pakete wenn möglich.')"
      ),
      con = lib_file
    )
  }
  
  # # Quarto render ----
  # # helper function erstellen
  # render_script <- path(project_path, "scripts", "render_report.R")
  # writeLines(
  #   c(
  #     "# scripts/render_report.R",
  #     "if (!requireNamespace('quarto', quietly = TRUE)) install.packages('quarto')",
  #     "",
  #     "render_report <- function(input_qmd, output_name = NULL, output_dir = 'reports') {",
  #     "  if (is.null(output_name)) {",
  #     "    output_name <- paste0(tools::file_path_sans_ext(basename(input_qmd)), '.html')",
  #     "  }",
  #     "  quarto::quarto_render(",
  #     "    input = input_qmd,",
  #     "    output_file = output_name",
  #     "  )",
  #     "  file.rename(output_name, file.path(output_dir, output_name))",
  #     "  message('✅ Bericht gerendert: ', file.path(output_dir, output_name))",
  #     "}"
  #   ),
  #   con = render_script
  # )
  
  # Tests ----
  validation_file <- path(project_path, "tests", "validate_input_data.R")
  writeLines(
    c(
      "# validate_input_data.R",
      "# Einfache Datenprüfungen",
      "# Beispiel: data <- read.csv('data/raw/data.csv')",
      "# str(data)",
      "# summary(data)",
      "# anyDuplicated(data)",
      "# sapply(data, function(x) sum(is.na(x)))"
    ),
    con = validation_file
  )

  
  # config.yaml ----
  # Konfigurationsdatei 
  config <- list(
    project_name = project_name,
    created = today,
    user = Sys.info()["user"]
  )
  write_yaml(config, file.path(project_path, "config.yaml"))
  
  # quarto.yml ----
  # für Quarto Projektstruktur
  quarto_config <- list(
    project = list(
      type = "default",
      `output-dir` = "reports",
      `execute-dir` = "project"
    )
  )
  
  write_yaml(quarto_config, file.path(project_path, "_quarto.yml"))
  
  
  # read_config.R ----
  # Helper Skript
  read_config_file <- path(project_path, "scripts", "read_config.R")
  if (!file_exists(read_config_file)) {
    writeLines(
      c(
        "# scripts/read_config.R",
        "",
        "read_project_config <- function(config_path = 'config.yaml') {",
        "  if (!file.exists(config_path)) {",
        "    warning('⚠️ config.yaml nicht gefunden, Default-Werte werden genutzt.')",
        "    return(list(project_name = 'Unknown Project', created = Sys.Date(), user = Sys.info()['user']))",
        "  }",
        "  yaml::read_yaml(config_path)",
        "}"
      ),
      con = read_config_file
    )
  }
  
  
  # Report Template ----
  report_file <- path(project_path, paste0(project_name, "_report.qmd"))
  if (!file_exists(report_file)) {
    writeLines(
      c(
        "---",
        paste0('title: "', project_name, ' – Report"'),
        "format:",
        "  html:",
        "    self-contained: true",
        paste0('    output-file: "', project_name, '_report.html"'),
        "execute-dir: project",
        "---",
        "",
        "```{r}",
        "#| include: false",
        "library(here)",
        "library(yaml)",
        "source(here('scripts', 'read_config.R'))",
        "config <- read_project_config()",
        "setwd(here())",
        "```",
        "",
        "# Übersicht",
        "",
        "Projekt: `r config$project_name`  ",
        "Erstellt am: `r config$created`  ",
        "Autor: `r config$user`",
        "",
        "## Analyse",
        "",
        "```{r}",
        "#| include: false",
        "",
        "source('M:/Projekte/global_tools/project_starter.R')",
        "source('M:/Projekte/global_tools/functions.R')",
        "source(here('scripts', 'load_lib.R'))",
        "```"
      ),
      con = report_file
    )
  }
  
  
 
  
  # README ----
  if (create_readme) {
    readme_file <- path(project_path, "README.qmd")
    writeLines(
      c(
        "---",
        paste0('title: "', project_name, ' – README"'),
        "format:",
        "  html:",
        "    toc: true",
        "    toc-depth: 2",
        "    number-sections: true",
        "    self-contained: true",
        "    output-file: README.html",
        "---",
        
        
        "",
        paste0("# Projekt: ", project_name),
        "",
        
        
        "## Autor",
        paste0("- Benutzer: ", Sys.info()[['user']]),
        paste0("- Erstellt am: ", today),
        "",
        
        
        "## Übersicht",
        "- `data/`: Roh- und bereinigte Daten",
        "- `scripts/`: Analyse-Skripte",
        "- `results/`: Ergebnisse & Outputs",
        "- `reports/`: Reports",
        "- `notebooks/`: Notizen",
        "- `tests/`: Tests",
        "",
        "",
        "## Dokumentation",
        "# Relevante Formeln etc.",
        "",
        "## R - Setup",
        "```{r}",
        "",
        "```"
      ),
      con = readme_file
    )
  }
  
  # .gitignore ----
  if (include_gitignore) {
    gitignore_content <-
      c(
        "# R",
        ".Rhistory",
        ".RData",
        ".Rproj.user",
        "",
        "# renv",           # renv Library
        "renv/library/",
        "renv/python/",
        "renv/staging/",
        "",
        "# Daten",
        "data/raw/",
        "*.xlsx",
        "*.csv",
        "*.rds",
        "",
        "# Ergebnisse",
        "results/",
        "",
        "# HTML/PDF",
        "*.html",
        "*.pdf",
        "",
        "# Sensible Files",
        "scripts/config.R",
        ".Renviron",         # R 
        ".env"               # Python 
      )
    
    writeLines(gitignore_content, file.path(project_path, ".gitignore"))
    
    message("✅ .gitignore wurde erstellt und enthält jetzt Schutz für sensible Daten.")
  }
  
  
  
  # .Renviron ----
  # Für API tokens oder sensible andere Schlüssel
    renviron_path <- file.path(project_path, ".Renviron")
    if (!file.exists(renviron_path)) {
      writeLines(
        c(
          "# Projektweite Umgebungsvariablen",
          "# Beispiel:",
          "# API_TOKEN = dein_token",
          "# api_url   = 'https:// ... '"
        ),
        con = renviron_path
    )
      message("✅ Leere .Renviron-Datei wurde erstellt für API-Keys und Passwörter.")
      
  }
  
  # renv ----
  if (include_renv) {
    if (requireNamespace("renv", quietly = TRUE)) {
      message("🔒 Initialisiere renv für Projekt: ", project_name)
      renv::scaffold(project = project_path)
      message("📦 Projektstruktur erstellt.")
      
      withr::with_dir(project_path, {
        
        if (file.exists("scripts/load_lib.R")) {
          source("scripts/load_lib.R")
        }
        renv::snapshot(prompt = FALSE)
      })
      
      message("📦 renv.lock aktualisiert für Projekt: ", project_name)
    } else {
      warning("⚠️ renv Paket nicht installiert. Projekt wird ohne renv erstellt.")
    }
  } else {
    message("ℹ️️ Projekt wurde ohne renv erstellt.")
  }
  
  message("✅ Projekt '", project_name, "' wurde erstellt unter: ", project_path)

}







create_results_wd <- function(analysis_type){
  today <- format(Sys.Date(), "%Y-%m-%d")
  results_dir <- file.path("results", paste0(today, "_", analysis_type))
  if (!dir.exists(results_dir)) dir.create(results_dir, recursive = TRUE)
  return(results_dir)
}











create_tests_wd <- function(analysis_type){
  today <- format(Sys.Date(), "%Y-%m-%d")
  results_dir <- file.path("tests", paste0(today, "_", analysis_type))
  if (!dir.exists(results_dir)) dir.create(results_dir, recursive = TRUE)
  return(results_dir)
}











create_notebook_wd <- function(topic = "notizen") {
  today <- format(Sys.Date(), "%Y-%m-%d")
  notebook_name <- paste0(today, "_", topic, ".qmd")
  notebook_path <- file.path("notebooks", notebook_name)
  
  if (!dir.exists("notebooks")) dir.create("notebooks", recursive = TRUE)
  
  if (!file.exists(notebook_path)) {
    writeLines(
      c(
        paste0("# Notizen – ", today),
        "",
        paste0("**Thema:** ", topic),
        paste0("**Projekt:** ", basename(here::here())),
        paste0("**Datum:** ", today),
        paste0("**User:** ", Sys.info()["user"]),
        paste0("**Session:** ", R.version.string),
        "",
        "## Ziel(e)",
        "",
        "- ",
        "",
        "## Schritte",
        "",
        "- ",
        "",
        "## Beobachtungen",
        "",
        "- ",
        "",
        "## Probleme / Nächste Schritte",
        "",
        "- "
      ),
      con = notebook_path
    )
    message("✅ Notebook erstellt: ", notebook_path)
  } else {
    message("⚠️ Notebook existiert schon: ", notebook_path)
  }
  
  return(notebook_path)
}













save_cleaned_result <- function(data, 
                                filename_prefix = "cleaned_data", 
                                cleaned_dir = "data/cleaned", 
                                write_csv2 = FALSE) {
  
  # Sicherstellen, dass Ordner existiert
  if (!dir.exists(cleaned_dir)) dir.create(cleaned_dir, recursive = TRUE)
  
  # Datum
  today <- format(Sys.Date(), "%Y-%m-%d")
  
  # Dateinamen erzeugen
  base_name <- paste0(filename_prefix, "_", today)
  path_rds   <- file.path(cleaned_dir, paste0(base_name, ".rds"))
  path_csv   <- file.path(cleaned_dir, paste0(base_name, ".csv"))
  path_xlsx  <- file.path(cleaned_dir, paste0(base_name, ".xlsx"))
  
  # Speichern
  saveRDS(data, path_rds)
  
  if (write_csv2) {
    write.csv2(data, path_csv, row.names = FALSE)  # mit ; als Separator (z.B. für Excel unter Windows)
  } else {
    write.csv(data, path_csv, row.names = FALSE)   # mit , als Separator
  }
  
  if (!requireNamespace("openxlsx", quietly = TRUE)) install.packages("openxlsx")
  openxlsx::write.xlsx(data, path_xlsx)
  
  message("✅ Gespeichert als: ", basename(path_rds), ", ", basename(path_csv), ", ", basename(path_xlsx))
  
  invisible(list(rds = path_rds, csv = path_csv, xlsx = path_xlsx))
}





```
